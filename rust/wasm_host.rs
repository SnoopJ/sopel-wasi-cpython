use std::path::Path;

use wasi_common::sync::Dir;
use wasmtime::*;
use wasmtime_wasi::preview2::{WasiCtx, WasiCtxBuilder, DirPerms, FilePerms};

use pyo3::prelude::*;
use pyo3::{wrap_pyfunction, wrap_pymodule};
use pyo3::types::{PyBytes};


struct WasiHostCtx {
    preview2_ctx: WasiCtx,
    preview2_table: wasmtime::component::ResourceTable,
    preview1_adapter: wasmtime_wasi::preview2::preview1::WasiPreview1Adapter,
}

impl wasmtime_wasi::preview2::WasiView for WasiHostCtx {
    fn table(&mut self) -> &mut wasmtime::component::ResourceTable {
        &mut self.preview2_table
    }

    fn ctx(&mut self) -> &mut WasiCtx {
        &mut self.preview2_ctx
    }
}

impl wasmtime_wasi::preview2::preview1::WasiPreview1View for WasiHostCtx {
    fn adapter(&self) -> &wasmtime_wasi::preview2::preview1::WasiPreview1Adapter {
        &self.preview1_adapter
    }

    fn adapter_mut(&mut self) -> &mut wasmtime_wasi::preview2::preview1::WasiPreview1Adapter {
        &mut self.preview1_adapter
    }
}


#[pyfunction]
#[pyo3(pass_module)]
#[pyo3(signature = (cpython_args, fuel=None, stdout_nbytes=None, stderr_nbytes=None))]
fn run_cpython<'py>(
    module: &Bound<'py, PyModule>,
    py: Python,
    cpython_args: Vec<String>,
    fuel: Option<u64>,
    stdout_nbytes: Option<usize>,
    stderr_nbytes: Option<usize>,
) -> PyResult<(Py<PyBytes>, Py<PyBytes>)> {
    let mut config = Config::new();
    config
        .cache_config_load_default()?
        .wasm_threads(true)
        .wasm_backtrace(false)
        .consume_fuel(fuel.is_some());
    let engine = Engine::new(&config)?;

    let mut linker: Linker<WasiHostCtx> = Linker::new(&engine);
    wasmtime_wasi::preview2::preview1::add_to_linker_sync(&mut linker)?;

    // Create a WASI context and put it in a Store; all instances in the store
    // share this context. `WasiCtxBuilder` provides a number of ways to
    // configure what the target program will have access to.
    let mut builder = WasiCtxBuilder::new();

    // NOTE:2024-07-28:snoopj:If the program attempts to write more bytes than this, the WASM guest
    // exits with a nonzero code. I'm not sure if there's a more reasonable behavior here, but it's
    // configurable from the Python calling side at least. 4K is more than enough for my needs.
    let stdoutpipe = wasmtime_wasi::preview2::pipe::MemoryOutputPipe::new(match stdout_nbytes {
        None => 4096,
        Some(val) => val,
    });
    let stderrpipe = wasmtime_wasi::preview2::pipe::MemoryOutputPipe::new(match stderr_nbytes {
        None => 4096,
        Some(val) => val,
    });
    builder
        .stdout(stdoutpipe.clone())
        .stderr(stderrpipe.clone());

    builder.arg("/opt/CPython-WASI/python.wasm");  // argv[0]
    for arg in cpython_args {
        builder.arg(&arg);
    }

    // Mount stdlib as read-only. This is a WASI 0.2 AKA preview2 only feature, it's why this is written in
    // Rust at all, because it's not yet exposed in the wasmtime-py API
    let mod_file = module.filename()?.to_string();
    let here = Path::new(&mod_file).parent().unwrap();
    let wasm_path = here.join("CPython-WASI").join("python.wasm");
    let stdlib_path = here.join("CPython-WASI").join("stdlib");

    let stdlib_host = Dir::from_std_file(std::fs::File::open(stdlib_path)?);
    let stdlib_guest = "/opt/CPython-WASI/wasm-site-packages";
    let dir_perms = DirPerms::READ;
    let file_perms = FilePerms::READ;
    builder.preopened_dir(stdlib_host, dir_perms, file_perms, stdlib_guest);
    builder.env("PYTHONPATH", stdlib_guest);

    let wasi_ctx = builder.build();
    let host_ctx = WasiHostCtx {
        preview2_ctx: wasi_ctx,
        preview2_table: wasmtime::component::ResourceTable::new(),
        // NOTE:2024-07-25:snoopj:to the best of my recollection, this adapter business and custom
        // struct is necessary because the WASI build generated by CPython's build process depends
        // on some preview1 stuff, and wasmtime makes it kind of clumsy to support these. As far as
        // I can tell, it's even more clumsy in newer versions of wasmtime. I tried my best to use
        // a newer version of wasmtime and the necessary code changes here exhausted my patience.
        preview1_adapter: wasmtime_wasi::preview2::preview1::WasiPreview1Adapter::new(),
    };
    let mut store = Store::new(&engine, host_ctx);
    if fuel.is_some() {
        store.set_fuel(fuel.unwrap())?;
    }

    // Instantiate our module with the imports we've created, and run it.
    let module = Module::from_file(&engine, wasm_path)?;
    linker.module(&mut store, "", &module)?;
    linker
        .get_default(&mut store, "")?
        .typed::<(), ()>(&store)?
        .call(&mut store, ())?;

    let stdout_bytes = PyBytes::new_bound(py, &stdoutpipe.contents().to_vec());
    let stderr_bytes = PyBytes::new_bound(py, &stderrpipe.contents().to_vec());

    Ok((stdout_bytes.into(), stderr_bytes.into()))
}


#[pymodule]
fn cpython_wasi_wrapper(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_function(wrap_pyfunction!(run_cpython, m)?)?;
    Ok(())
}

#[pymodule]
fn sopel_wasi_cpython(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_wrapped(wrap_pymodule!(cpython_wasi_wrapper))?;
    Ok(())
}
